<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sortings Benchmark: ArraySortings</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sortings Benchmark
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">ArraySortings </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Repository with sorting methods and benchmarking facilities.</p>
<p><a href="https://b1z0n.github.io/SortingBenchmark/"><b>Documentation</b></a></p>
<h1>Compilation</h1>
<p>Use <code>g++ some.cpp -o some -std=c++17</code>.</p>
<p>Other compilers not guaranteed to work.</p>
<p>Include <code><a class="el" href="sort__bench_8hpp.html">benchmark/sort_bench.hpp</a></code>. </p><h1>Features</h1>
<p>All of this, you could find in namespace <code>srtbch</code> (spell as SortBench) </p><h2>ArrayElement</h2>
<p>Is a template class that helps with counting of comparisons and assignments operation. Designed to count this values automatically. For example: </p><div class="fragment"><div class="line">{c++}</div><div class="line">std::array&lt;ArrayElement&lt;int&gt;, 10&gt; arr{};</div><div class="line">std::generate(std::begin(arr), std::end(arr), some_gen_func);</div><div class="line"></div><div class="line">some_sort_func(arr.data(), arr.size());</div><div class="line"></div><div class="line">std::cout &lt;&lt; &quot;Comparisons: &quot; &lt;&lt; ArrayElement&lt;int&gt;::get_cmp()  &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; &quot;Assignments: &quot; &lt;&lt; ArrayElement&lt;int&gt;::get_asgn() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">ArrayElement&lt;int&gt;::reset();</div><div class="line">// start counting from zero</div></div><!-- fragment --><p> You could manually diasble/enable some of the counting facilites: </p><div class="fragment"><div class="line">{c++}</div><div class="line">ArrayElement&lt;int&gt;::off_on_cmp_count(true)   </div><div class="line">// means turn on comparison counting</div><div class="line"></div><div class="line">ArrayElement&lt;int&gt;::off_on_asgn_count(false) </div><div class="line">// means turn off assignment counting</div></div><!-- fragment --><p> Comparison and assignment operator support included. Looking forward to include some other operators for behaving much like T class itself. It will be usefull for testing some extraordinary sortings like radix sort. But that's ignored till this sortings being implemented(see "**Note about future**"). </p><h2>Element generation functions</h2>
<p>Remember: <b>PRNG stands for "pseudorandom number generator"</b> Remember: <b>Call <code>operator()</code> for generation</b></p>
<p>There are several classes that provides this feature(generation): </p><h3>Classes</h3>
<ul>
<li><code>SeededPRNG&lt;T, PRNG_T, size_t seed_len&gt;</code> template class that generates seed values for PRNG.<ul>
<li><code>T</code> - type for generating.</li>
<li><code>PRNG_T</code> - type of generator, should have a constructor, that accepts two iterators of seed <code>[begin, end]</code> range.</li>
<li><code>size_t seed_length</code> - length of seed iterable (nontype parameter). <code>SeedePRNG</code> meets the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomNumberEngine"><code>RandomNumberEngine</code></a>). You could use it like this: <div class="fragment"><div class="line">{c++}</div><div class="line">SeededPRNG&lt;int, some_prng, 624&gt; sprng {};</div><div class="line">std::cout &lt;&lt; &quot;Generated value: &quot; &lt;&lt; sprng() &lt;&lt; std::endl;</div></div><!-- fragment --> Doesn't matter what type of elements generates <code>PRNG_T</code> object, this PRNG turns them to <code>T</code>. Under the hood it is implemented with <a href="https://en.cppreference.com/w/cpp/numeric/random/random_device"><code>std::random_device</code></a>(for seed generating) and <a href="https://en.cppreference.com/w/cpp/string/byte/memcpy"><code>std::memcpy</code></a> for type conversion.</li>
</ul>
</li>
<li><code>Genfunctor_base&lt;InT, OutT, SeededPRNG_T&gt;</code> - template class for generating values of type <code>OutT</code> with help of seeded generator of type <code>SeededPRNG_T</code> that generates values of type <code>InT</code>.<ul>
<li><code>InT</code> and <code>OutT</code> should be of numeric types (real or integral).</li>
<li><code>SeededPRNG_T</code> must meet the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomNumberEngine"><code>RandomNumberEngine</code></a>. For classes that use heap, or mask their actual size(with pointers, for example) write your own manual generator, using this one. Class meets the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomNumberEngine"><code>RandomNumberEngine</code></a>).</li>
</ul>
</li>
<li><code>LimGenFunctor_base&lt;T, DistribT, GeneratorT&gt;</code> - class for generating limited values of different types with help of:<ul>
<li><code>T</code> - type being generated.</li>
<li><code>DistribT</code> - distribution of generation, that meets the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomNumberDistribution"><code>RandomNumberDistribution</code></a>.</li>
<li><code>GeneratorT</code> - generator, that meets the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/RandomNumberEngine"><code>RandomNumberEngine</code></a>). It is the base class, that sets interface to other classes. Constructor accepts values <code>const T&amp; from</code> and <code>const T&amp; to</code> that limit a range of generated values <code>[from, to]</code>.</li>
</ul>
</li>
<li><code>LimGenFunctorVal&lt;T, DistribT, GeneratorT, T from, T to&gt;</code> - doing the same thing as <code>LimGenFunctor_base&lt;T, DistribT, GeneratorT&gt;</code>, except of nontype parameters <code>from</code> and <code>to</code>, both of type <code>T</code>:<ul>
<li><code>T from</code> - value that shows the beginning of the interval.</li>
<li><code>T to</code> - value that shows the ending of the interval. Constructor accepts no parameters. Call <code>operator()</code> for generation. Values of some types couldn't be passed as nontype template parameter, double for example(precision problems) couldn't(according to C++17 standard(oh, i hope they will, i hope they will)). But this is an important strategical point - <b>sort variables of real types</b>. So the next class is a workaround to this problem.</li>
</ul>
</li>
<li><code>LimGenFunctorType&lt;T, DistribT, GeneratorT, From, To&gt;</code> - doing the same thing as <code>LimGenFunctor_base&lt;T, DistribT, GeneratorT&gt;</code>, except of type parameters <code>From</code> and <code>To</code>:<ul>
<li><code>From</code> - type that has <code>constexpr static</code> member of type <code>T</code> named <code>value</code>, that shows the beginning of the interval.</li>
<li><code>To</code> - type that has <code>constexpr static</code> member of type <code>T</code> named <code>value</code>, that shows the ending of the interval. Constructor accepts no parameters.</li>
</ul>
</li>
</ul>
<p>This are classes, but the most useful for end user will be type aliases for this classes: </p><h3>Type aliases</h3>
<p>First of all, all of this aliases are based on <a href="https://en.wikipedia.org/wiki/Mersenne_Twister">mt19937 generator</a> and uniform <a href="https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)">continuous</a> or <a href="https://en.wikipedia.org/wiki/Discrete_uniform_distribution">discrete</a> distribution.</p>
<ul>
<li><code>SeededMT</code> - mt19937 ready for generation of type <code>uint32_t</code>, seeded with <a href="https://en.cppreference.com/w/cpp/numeric/random/random_device"><code>std::random_device</code></a></li>
<li><code>GenFunctor&lt;InT, OutT, PRNG_T, size_t seedlen&gt;</code> - template class for creating own genfuncs<ul>
<li><code>InT</code> - type of seed values and generating of <code>PRNG_T</code> object.</li>
<li><code>OutT</code> - type, values of which are about to be generated.</li>
<li><code>PRNG_T</code> - type of generator, should have a constructor, that accepts two iterators of seed <code>[begin, end]</code> range.</li>
<li><code>size_t seed_length</code> - length of seed iterable (nontype parameter).</li>
</ul>
</li>
<li><code>unlimited_mtgenf&lt;OutT&gt;</code> - <code>mt19937</code> ready for generation of values, of type <code>OutT</code><ul>
<li><code>OutT</code> - should be numeric (real or integral), for nonnumeric values - turn on your imagination(it is easier than you think).</li>
</ul>
</li>
<li><code>lim_unif_int_mtgenf&lt;IntT, IntT from, IntTo&gt;</code> - spell as <em>limited, uniform distribution, integral, mersenne twister of seed length 19937 bits, generating function</em><ul>
<li><code>IntT</code> - type, values of which are about to be generated, should be integral (e.g <code>short int</code>, <code>long long</code>).</li>
<li><code>IntT from</code> - value that shows the beginning of the interval.</li>
<li><code>IntT to</code> - value that shows the ending of the interval.</li>
</ul>
</li>
</ul>
<p>Class uses <a href="https://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution"><code>std::uniform_int_distribution</code></a></p>
<p>Usage: </p><div class="fragment"><div class="line">{c++}</div><div class="line">lim_unif_int_mtgenf&lt;int, 3, 6&gt; gen {};</div><div class="line"></div><div class="line">std::cout &lt;&lt; gen() &lt;&lt; std::endl; // 3, 4, 5 or 6 ?</div></div><!-- fragment --><ul>
<li><code>lim_unif_real_mtgenf&lt;RealT&gt;</code> - limited generating function of real types<ul>
<li><code>IntT</code> - type, values of which are about to be generated, should be real (e.g <code>double</code>, <code>float</code>). It's constructor accepts <code>RealT from</code> and <code>RealT to</code> - range of values to be generated. Looking in long perspective, you'll want to make this constructor take zero arguments, so that you could pass this class to <code>SortBench</code> as a template template parameter. But due to c++ limitations(see <code>LimGenFunctorVal</code> above) we can't do this. So my recomendation is that you have two options, first is: <div class="fragment"><div class="line">{c++}</div><div class="line">class my_real_limited_e_pi : public lim_unif_real_mtgenf&lt;double&gt;</div><div class="line">{</div><div class="line">    using parent = lim_unif_real_mtgenf&lt;double&gt;;</div><div class="line">public:</div><div class="line">    my_real_limited_e_pi()</div><div class="line">        : parent{2.718, 3.141} {}</div><div class="line">};</div><div class="line"></div><div class="line">// now you can pass this as a type to SortBench</div></div><!-- fragment --> And the other option is the next item:</li>
</ul>
</li>
<li><code>lim_unif_real_mtgenf_type&lt;RealT, From, To&gt;</code> - limited generating function of real types<ul>
<li><code>From</code> - type that has <code>constexpr static</code> member of type <code>T</code> named <code>value</code>, that shows the beginning of the interval.</li>
<li><code>To</code> - type that has <code>constexpr static</code> member of type <code>T</code> named <code>value</code>, that shows the ending of the interval. Constructor accepts no parameters.</li>
</ul>
</li>
</ul>
<p>Like that: </p><div class="fragment"><div class="line">{c++}</div><div class="line">struct FromE {</div><div class="line">    constexpr static double value {2.718};</div><div class="line">};</div><div class="line"></div><div class="line">struct ToPi {</div><div class="line">    constexpr static double value {3.141};</div><div class="line">};</div><div class="line"></div><div class="line">using my_lim_genf = lim_unif_real_mtgenf_type&lt;double, FromE, ToPi&gt;;</div><div class="line">// now you can pass this as a type to SortBench</div></div><!-- fragment --><p> Both of the <code>lim_unif_real_mtgenf&lt;RealT&gt;</code> and <code>lim_unif_real_mtgenf_type&lt;RealT, From, To&gt;</code> use <a href="https://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution"><code>std::uniform_real_distribution</code></a></p>
<h2>Benchmark</h2>
<p><code>SortBench</code> is a class that helps in testing sorting functions, full declaration: <code>template &lt;typename T, template &lt;typename&gt; typename SortFunctor, typename GenFunc = unlimited_mtgenf&lt;T&gt;&gt;</code>, where:</p><ul>
<li><code>T</code> - type to be generated and sorted.</li>
<li><code>SortFunctor</code> - template that sorts arrays of type <code>T</code>, it should have <code>operator(T * array, size_t size)</code>.</li>
<li><code>GenFunc</code> - class, that generates values of type <code>T</code>(for <code>unlimited_mtgenf</code> and other interesting genfunctors look above).</li>
</ul>
<p>Simple usecase: </p><div class="fragment"><div class="line">{c++}</div><div class="line">template &lt;typename T&gt;</div><div class="line">struct BubbleSort</div><div class="line">// functors only supported</div><div class="line">// due to c++ limitations</div><div class="line">{</div><div class="line">      void operator()(T *arr, uint len) noexcept</div><div class="line">    // should have this method</div><div class="line">      {</div><div class="line">          for (uint i = 0; i &lt; len - 1; i++)</div><div class="line">              for (uint j = 0; j &lt; len - i - 1; j++)</div><div class="line">                if (arr[j] &gt; arr[j + 1])</div><div class="line">                    std::swap(arr[j], arr[j + 1])</div><div class="line">      }</div><div class="line">};</div><div class="line"></div><div class="line">SortBench&lt;int, BubbleSort&gt; srt;</div><div class="line"></div><div class="line">auto res {srt(4 /*array_size*/, 3 /*measure_num*/)};</div><div class="line">// 3 different arrays of size 4 being generated and tested</div><div class="line"></div><div class="line">output_sort_stats(res);</div><div class="line">// res of type SortStats</div><div class="line"></div><div class="line">std::cout &lt;&lt; &quot;Generated containers is: \n&quot;;</div><div class="line">print_container(std::cout, srt.notsorted_arrays());</div><div class="line">// container of start(notsorted) arrays</div><div class="line"></div><div class="line">std::cout &lt;&lt; &quot;And sorted containers is: \n&quot;;</div><div class="line">print_container(std::cout, srt.sorted_arrays());</div><div class="line">// container of end(sorted) arrays</div><div class="line"></div><div class="line">std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p> For print_container function see <a href="https://gist.github.com/B1Z0N/e122def9e42e2ee198519bb70642feda">this</a>. Now that we've seen basic example, let's light the details. There are such helper classes/aliases:</p><ul>
<li><code>CmpAsgn</code> - assembles comparisons and assignments in one structure.<ul>
<li><code>size_t cmp</code> - comparisons.</li>
<li><code>size_t asgn</code> - assignments.</li>
</ul>
</li>
<li><code>SortStats</code> - declared as follows: <div class="fragment"><div class="line">{c++}</div><div class="line">using SortStats = std::vector&lt;std::tuple&lt;</div><div class="line">                  size_t,                     // array length</div><div class="line">                  std::chrono::nanoseconds,   // sorting duration</div><div class="line">                  CmpAsgn                     // comparisons and assignments</div><div class="line">                  &gt;&gt;;</div></div><!-- fragment --> And here is the code, potentially useful for you: <div class="fragment"><div class="line">{c++}</div><div class="line">std::ostream&amp; ssoutput(std::ostream&amp; os, const srtbch::SortStats&amp; ss)</div><div class="line">{</div><div class="line">        // code for the output of the data</div><div class="line">        // returned from SortBench::operator() call</div><div class="line">        using namespace std::chrono;</div><div class="line"></div><div class="line">        for (auto &amp;[sz, tm, ca] : ss)</div><div class="line">        {</div><div class="line">                os &lt;&lt; &quot;size: &quot; &lt;&lt; sz &lt;&lt; &#39;.&#39;;</div><div class="line">                os &lt;&lt; &quot; time: &quot; &lt;&lt; (tm).count() &lt;&lt; &quot;ns.&quot;;</div><div class="line">                os &lt;&lt; &quot; comparisons: &quot; &lt;&lt; ca.cmp &lt;&lt; &#39;.&#39;;</div><div class="line">                os &lt;&lt; &quot; assignments: &quot; &lt;&lt; ca.asgn &lt;&lt; &#39;.&#39; &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line"></div><div class="line">        return os;</div><div class="line">}</div></div><!-- fragment --></li>
</ul>
<p>Main method of <code>SortBench</code> is <code>operator(...)</code>, it has two versions:</p><ul>
<li><code>SortStats operator()(std::vector&lt;size_t&gt; array_sizes)</code>, where <code>array_sizes</code> is array of sizes to be generated and tested</li>
<li><code>SortStats operator()(size_t array_size, size_t measure_num)</code>, where:<ul>
<li><code>array_size</code> - size of every array being generated</li>
<li><code>measure_num</code> - number of generations of arrays of size <code>array_size</code></li>
</ul>
</li>
</ul>
<p>Also if you want to keep start or end arrays you should state this explicitly with one of this methods:</p><ul>
<li><code>void keep_before(bool should = true)</code> to keep start arrays</li>
<li><code>void keep_after (bool should = true)</code> to keep end arrays</li>
<li>or via constructor: <code>SortBench(bool keep_before = false, bool keep_after = false)</code></li>
</ul>
<p>To access it, you should use appropriate methods:</p><ul>
<li><code>std::vector&lt;std::vector&lt;T&gt;&gt; notsorted_arrays()</code></li>
<li><code>std::vector&lt;std::vector&lt;T&gt;&gt; sorted_arrays()</code> <h2>Note about future</h2>
</li>
</ul>
<ol type="1">
<li>Planning to implement the very basic sortings.</li>
<li>Documentation site.</li>
<li>Implement concepts, or template type assertions. </li>
</ol>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
